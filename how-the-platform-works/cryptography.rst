.. _cryptography:

Криптография
====================

Для обеспечения безопасности в платформе Waves Enterprise используются криптографически стойкие алгоритмы, соответствующие требованиям ГОСТ, а также квалифицированные электронные подписи.

Платформа предоставляет выбор используемой криптографии, которая базируется на одном из стандартов:

- ГОСТ-криптография - для реализации проектов в государственных структурах и ведомствах;
- Эллиптическая кривая Curve25519 - для проектов, в которых не требуется строгое соответствие ГОСТу (коммерческие компании, организации за пределами РФ).

Предварительная обработка данных
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Все байтовые последовательности перед операциями хеширования или подписания преобразовываются по алгоритму Base58 или Base64.

.. hint:: Base64 — стандарт кодирования двоичных данных при помощи 64 символов ASCII. Алфавит кодирования содержит латинские символы и цифры A-Z, a-z и 0-9 (62 знака) и 2 служебных символа. Каждые 3 исходных байта кодируются 4 символами (увеличение на ¹⁄₃).

.. hint:: Base58 — вариант кодирования двоичных данных в виде буквенно-цифрового текста на основе латинского алфавита. Содержит 58 символов, исключены используемые в base64 символы 0, O, I, l, +, / . Применяется для передачи данных в разнородных сетях (транспортное кодирование). 

.. _crypto-gost:

ГОСТ-криптография
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Алгоритм хэширования реализован по ГОСТ Р 34.11 2012 "Информационная технология. Криптографическая защита информации. Функция хэширования". 
Используется функция «Стрибог» с размером блоков выходных данных 256 бит.

Алгоритмы формирования и проверки ЭЦП реализованы по ГОСТ Р 34.10-2012 "Информационная технология. Криптографическая защита информации. Процессы формирования и проверки электронной цифровой подписи". Длина ключей 256 бит.

.. _crypto-waves:

Использование эллиптической кривой Curve25519 (криптография Waves)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Алгоритм хэширования реализован последовательным хешированием функциями Blake2b256 и Keccak256. Размер блоков выходных данных 256 бит.

Алгоритмы формирования и проверки ЭЦП реализованы на базе эллиптической кривой Curve25519 (ED25519 с ключами X25519). Длина ключей 256 бит.

.. _crypto-data-tx:

Зашифрование текстовых данных в транзакциях
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Платформа Waves Enterprise предоставляет возможность зашифрования/расшифрования текстовых данных при помощи сессионных ключей. Опция применяется для зашифрования любого вида текстовой информации, например, параметры Docker контрактов или данные из транзакций :ref:`Data Transaction <DataTransaction>`. Зашифрование текстовых данных может выполняться как индивидуально для каждого получателя, с формированием уникального экземпляра шифротекста, так и с формированием единого шифротекста для группы получателей. Ограничение на размер зашифровываемых данных - 165Кб. Алгоритмы хеширования соответствуют выбранной схеме криптографии (ГОСТ или Waves).

Алгоритм зашифрования
"""""""""""""""""""""""""""

Для зашифрования/расшифрования данных применяются симметричные ключи CEK и KEK. CEK (Content Encryption Key) это ключ для зашифрования текстовых данных, KEK (Key Encryption Key) это ключ для зашифрования CEK. Ключ CEK формируется нодой случайным образом с применением соответствующих алгоритмов хеширования. Ключ KEK формируется нодой на базе алгоритма Diffie-Hellman, используя публичные и приватные ключи отправителя и получателей, и применяется для зашифровывания ключа CEK.

Симметричный ключ СЕК недоступен для прочтения и не отображается в процессе шифрования. От отправителя к получателю он передается в зашифрованном виде (wrappedKey) по открытым каналам связи вместе с зашифрованным сообщением. Одним из таких каналов может являться запись в блокчейн - DataTransaction или стейт смарт-контракта. Ключ КЕК от отправителя к получателю не передается, он восстанавливается получателем на основе своего закрытого ключа и известного публичного ключа отправителя (алгоритм Diffie-Hellman key exchange).

Зашифрование/расшифрование текстовых данных выполняется при помощи метода :ref:`crypto <crypto>`. Данный метод позволяет зашифровывать текст отдельно для каждого получателя или для всех получателей вместе.

 .. figure:: img/DHcrypto.png
          :scale: 50 %
          :align: center
          :figwidth: 100 %
          :alt: Процедура зашифрования текстовых данных на базе алгоритма Diffie-Hellman

          Процедура зашифрования текстовых данных на базе алгоритма Diffie-Hellman

Процесс зашифрования/расшифрования данных включает в себя следующие действия:

1. Для зашифровывания данных для каждого получателя отдельно используется метод :ref:`POST /crypto/encryptSeparate <encryptSeparate>`. Укажите в JSON запросе следующие параметры:

* ``sender`` - адрес отправителя.
* ``password`` - пароль от ключевой пары отправителя, создаваемый вместе с аккаунтом.
* ``encryptionText`` - текст для зашифрования.
* ``recipientsPublicKeys`` - массив публичных ключей получателей.

2. Для зашифровывания данных для всех получателей единым ключом CEK используется метод :ref:`POST /crypto/encryptCommon <encryptCommon>`. Укажите в JSON запросе параметры, аналогичные методу :ref:`POST /crypto/encryptSeparate <encryptSeparate>`.

3. Для расшифровывания данных используется метод :ref:`POST /crypto/decrypt <decrypt>`. Укажите в JSON запросе следующие параметры:

* ``recipient`` - адрес получателя.
* ``password`` - пароль от ключевой пары получателя, создаваемый вместе с аккаунтом.
* ``encryptedText`` - зашифрованный текст.
* ``wrappedKey`` - обёрнутый ключ, полученный при зашифровании данных.
* ``senderPublicKey`` - публичный ключ отправителя.

.. 
    1. Нода зашифровывает текстовые данные при помощи ключа CEK. Если необходимо формирование зашифрованных данных для каждого получателя отдельно, то формируются уникальные CEK ключи для каждого получателя. Таким образом, каждый получатель принимает текстовые данные, зашифрованные только для него. В случае использования общего CEK ключа зашифрованные данные у всех получателей будут одинаковые.
    2. Нода формирует KEK ключи, используя публичные и приватные ключи получателей и отправителя.
    3. Нода зашифровывает CEK ключ при помощи KEK ключей, формируя обёрнутые ключи (wrapedKey) для каждого получателя отдельно.
    4. Зашифрованные данные вместе с ключами wrapedKey кладутся в транзакцию, которая попадает в блокчейн.
    5. Расшифрование текстовых данных транзакции выполняется нодой с использованием KEK и CEK ключей в обратном процессу зашифрования порядке.



